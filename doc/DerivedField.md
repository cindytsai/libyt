# Derived Field
## Definition of Derived Field
When you want your simulation code to generate or convert existing data to `yt`-needed type, you should set to this option. Field data will be generated by your input function `derived_func`, whenever `yt` needs them, which is during the in situ process.

## Use `libyt` API to Build Derived Field Function
### Derived Field Function

Derived functions have prototype like this respectively:
- `derived_func(const int, const long*, const char*, yt_array*)`: generate field data of that grid when input a list grid id.

  ```c++
  void DerivedFunc(const int list_len, const long *list_gid, const char *field_name, yt_array *data_array);
  ```
  - `const int list_len`: number of gid in `list_gid`.
  - `const long *list_gid`: a list of grid id that this function needs to prepare.
  - `const char *field_name`: target field data name to prepare.
  - `yt_array *data_array`: write generated data to the pointer in this array in the same order in `list_gid`. See below for how to fill in data.

Derived functions `derived_func` generates required data and stores at `yt_array` array data member `data_ptr` without ghost cell. Make sure your function writes the data in x-address alters first orientation (which is [z][y][x]), if `contiguous_in_x` is set to `true`. Write the data in z-address alters first orientation (which is [x][y][z]), if `contiguous_in_x` is set to `false`.

- `yt_array`
  - Usage: a struct used in derived function and get particle attribute function.
  - Data Member:
    - `long gid`: grid id.
    - `long data_length`: length of `data_ptr`.
    - `void *data_ptr`: data pointer where you should write in field data of this grid.




### Get Grid Information API

#### yt\_getGridInfo\_Dimensions
```cpp
int yt_getGridInfo_Dimensions( const long gid, int (*dimensions)[3] );
```
- Usage: Get dimension of grid `gid`. `dimensions[0]` corresponds to dimension in x-axis, `dimensions[1]` corresponds to dimension in y-axis, and `dimensions[2]` corresponds to dimension in z-axis, excluding ghost cells.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_LeftEdge
```cpp
int yt_getGridInfo_LeftEdge(const long gid, double (*left_edge)[3]);
```
- Usage: Get left edge of grid `gid`. `left_edge[0]` is left edge of the grid in x-axis in code length, `left_edge[1]` for y-axis, and `left_edge[2]` for z-axis.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_RightEdge
```cpp
int yt_getGridInfo_RightEdge(const long gid, double (*right_edge)[3]);
```
- Usage: Get right edge of grid `gid`. `right_edge[0]` is right edge of the grid in x-axis in code length, `right_edge[1]` for y-axis, and `right_edge[2]` for z-axis.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_ParentId
```cpp
int yt_getGridInfo_ParentId(const long gid, long *parent_id);
```
- Usage: Get parent grid id of grid `gid`. If there is no parent grid, `parent_id` will be `-1`.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_Level
```cpp
int yt_getGridInfo_Level(const long gid, int *level);
```
- Usage: Get level of grid `gid`. It is 0-indexed. If grids are on root level, `level` will be `0`.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_ProcNum
```cpp
int yt_getGridInfo_ProcNum(const long gid, int *proc_num);
```
- Usage: Get MPI process number (MPI rank) of grid `gid` located on.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_ParticleCount
```cpp
int yt_getGridInfo_ParticleCount(const long gid, const char *ptype, long *par_count);
```
- Usage: Get number of particle `ptype` located on grid `gid`.
- Return: `YT_SUCCESS` or `YT_FAIL`
> :information_source: Particle type name `ptype` should be same as what you passed in `yt_get_particlesPtr`.

#### yt\_getGridInfo\_FieldData
```cpp
int yt_getGridInfo_FieldData( const long gid, const char *field_name, yt_data *field_data);
```
- Usage: Get the field data `field_name` in grid id `gid`. The result will be stored in `field_data`.
- Return: `YT_SUCCESS` or `YT_FAIL`
- `yt_data`
  - `data_ptr`: Data pointer.
  - `data_dimensions[3]`: Dimension of the `data_ptr` array, in the point of view of itself.
  - `data_dtype`: Data type of the array.

> :information_source: Field name `field_name` should be same as what you passed in `yt_get_fieldsPtr`.

> :information_source: Do not mix grid dimensions get by `yt_getGridInfo_Dimensions` with data dimensions get by `yt_getGridInfo_FieldData`. Grid dimensions are grid length in [0][1][2] <-> [x][y][z], excluding ghost cells. Whereas data dimensions are just data length in data's point of view, which may consist of ghost cells.

> :warning: You should not be modifying `data_ptr`, as they are those data pointers you passed in and will be used in your later on iterations.

## Example
Field `InvDens` is a derived field and is reciprocal of density field `Dens`. `derived_func_InvDens` first gets level, grid dimensions and density data of the grid, and it generates data and stores them in `data_array`.
```cpp
// get pointer of the array where we should put data to
yt_field *field_list;
yt_get_fieldsPtr(&field_list);

// Reciprocal of density field "InvDens"
field_list[1].field_name = "InvDens";
field_list[1].field_type = "derived_func";
field_list[1].contiguous_in_x = true;
field_list[1].field_dtype = (typeid(real) == typeid(float)) ? YT_FLOAT : YT_DOUBLE;
field_list[1].derived_func = derived_func_InvDens;

void derived_func_InvDens(const int list_len, const long *gid_list, const char *field_name, yt_array *data_array) {
    // loop over gid_list, and fill in grid data inside data_array.
    for (int lid = 0; lid < list_len; lid++) {
        // =================================================
        // libyt: [Optional] Use libyt look up grid info API
        // =================================================
        int level, dim[3];
        yt_getGridInfo_Level(gid_list[lid], &level);
        yt_getGridInfo_Dimensions(gid_list[lid], &dim);
    
        // =============================================================
        // libyt: [Optional] Use libyt API to get data pointer passed in
        // =============================================================
        // the label "Dens" we used here should be same as yt_get_fieldsPtr (libyt step 4)
        yt_data dens_data;
        yt_getGridInfo_FieldData(gid_list[lid], "Dens", &dens_data);
        
        // generate and fill in data in [z][y][x] order, since we set this field contiguous_in_x = true
        int index, index_with_ghost_cell;
        for (int k = 0; k < dim[2]; k++) {
            for (int j = 0; j < dim[1]; j++) {
                for (int i = 0; i < dim[0]; i++) {
                index = k * dim[1] * dim[0] + j * dim[0] + i;
                index_with_ghost_cell =  (k + GHOST_CELL) * (dim[1] + GHOST_CELL * 2) * (dim[0] + GHOST_CELL * 2)
                                       + (j + GHOST_CELL) * (dim[0] + GHOST_CELL * 2)
                                       + (i + GHOST_CELL);
                
                // write generated data in data_array allocated by libyt.
                ((real *) data_array[lid].data_ptr)[index] = 1.0 / ((real *) dens_data.data_ptr)[index_with_ghost_cell];
                }
            }
        }
    }
}
```