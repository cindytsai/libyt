# Derived Field
## Definition of Derived Field
When you want your simulation code to generate or convert existing data to `yt`-needed type, you should set to this option. These field data will be generated by your input function `derived_func`, whenever `yt` needs them.

These functions will only be called when `yt` is doing analysis, which is when  `yt_inline` or `yt_inline_argument` API is called.

## Use `libyt` API to Build Derived Field Function
### Derived Field Function
`derived_func` should be able to write the correspond output into the array passed in, just by knowing the grid id. It should not generate ghost cell data. Make sure your function writes the data in x-address alters first orientation (which is [z][y][x]), if `swap_axes` is set to `true`. Write the data in z-address alters first orientation (which is [x][y][z]), if `swap_axes` is set to `false`.

`derived_func` must have a prototype like this:
```cpp
void DerivedFunc(long gid, double *output);
```
The first argument will pass in the grid id, the second argument is an empty array where you should put your output to.

### Get Grid Information API

#### yt\_getGridInfo\_Dimensions
```cpp
int yt_getGridInfo_Dimensions( const long gid, int (*dimensions)[3] );
```
- Get dimension of the grid id `gid`, `dimensions[0]` corresponds to length of x, `dimensions[1]` corresponds to length of y, and `dimensions[2]` corresponds to length of z.

#### yt\_getGridInfo\_FieldData
```cpp
int yt_getGridInfo_FieldData( const long gid, const char *field_name, yt_data *field_data);
```
- Get the field data `field_name` in grid id `gid`. The result will be stored in `field_data`.
- yt_data
  - `data_ptr`: Data pointer.
  - `data_dimensions[3]`: Dimension of the `data_ptr` array, in the point of view of itself.
  - `data_dtype`: Data type of the array.

> :information_source: Do not mix grid dimensions get by `yt_getGridInfo_Dimensions` with data dimensions get by `yt_getGridInfo_FieldData`. Grid dimensions are grid length in [0][1][2] <-> [x][y][z]. Whereas data dimensions are just data length in data's point of view, which may consist of ghost cells.

> :warning: You should not be modifying `data_ptr`, as they are those data pointers you passed in and will be used in your later on iterations.

## Example
This example assigns derived function `MagX_DerivedFunc` to the function pointer `derived_func` in field `CCMagX`.
```cpp
void MagX_DerivedFunc(long gid, double *Converted_MagX);
...
void YT_Inline(){
    ...
    yt_field *FieldList;
    yt_get_fieldsPtr( &FieldList );
	
    FieldList[MHDIdx].field_name        = "CCMagX";
    FieldList[MHDIdx].field_define_type = "derived_func";
    FieldList[MHDIdx].swap_axes         = true;
    FieldList[MHDIdx].derived_func      = MagX_DerivedFunc;
    ...
}
```

`MagX_DerivedFunc` is capable of writing outputs to the passed in array with a given grid id.
```cpp
void MagX_DerivedFunc(long gid, double *Converted_MagX)
{
    // Get the dimension of the grid, and the data array pointer of the grid
    int Dimensions[3];
    yt_data DataRaw;
    yt_getGridInfo_Dimensions( gid, &Dimensions );
    yt_getGridInfo_FieldData( gid, "MagX", &DataRaw );

    // Cast the DataRaw by its data type
    if (DataRaw.data_dtype == YT_FLOAT)
        float  *Data = (float *)  DataRaw.data_ptr;
    if (DataRaw.data_dtype == YT_DOUBLE)
        double *Data = (double *) DataRaw.data_ptr;
    
    // Compute converted field via data. [z, y, x] direction.
    for (int k=0; k<Dimensions[2]; k++){
        for (int j=0; j<Dimensions[1]; j++){
            for (int i=0; i<Dimensions[0]; i++){
                int idx_Bx = IDX321_BX(i, j, k, Dimensions[0], Dimensions[1]);
                int idx_cc = i + j * Dimensions[0] + k * Dimensions[0] * Dimensions[1];
                Converted_MagX[idx_cc] = (double) 0.5 * ( Data[ idx_Bx ] + Data[ idx_Bx + 1 ] );
            }
        }
    }
}
```