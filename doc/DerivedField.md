# Derived Field
## Definition of Derived Field
When you want your simulation code to generate or convert existing data to `yt`-needed type, you should set to this option. These field data will be generated by your input function `derived_func` or `derived_func_with_name`, whenever `yt` needs them.

These functions will only be called when `yt` is doing analysis, which is when  `yt_inline` or `yt_inline_argument` API is called.

## Use `libyt` API to Build Derived Field Function
### Derived Field Function

Derived functions have prototype like this respectively:
- `derived_func(int, long*, yt_array*)`: generate field data of that grid when input grid id.
  ```c++
  void DerivedFunc(int list_len, long *list_gid, yt_array *data_array);
  ```
  - `int list_len`: number of gid in `list_gid`.
  - `long *list_gid`: a list of grid id data to prepare.
  - `yt_array *data_array`: write generated data to the pointer in this array correspondingly. See below for how to fill in data.
- `derived_func_with_name(int, long*, char*, yt_array*)`: generate field data of that grid when input grid id and field name.
  ```c++
  void DerivedFuncWithName(int list_len, long *list_gid, char *field, yt_array *data_array);
  ```
  - `int list_len`: number of gid in `list_gid`.
  - `long *list_gid`: a list of grid id data to prepare.
  - `char *field`: target field name.
  - `yt_array *data_array`: write generated data to the pointer in this array correspondingly. See below for how to fill in data.

Derived functions `derived_func` and `derived_function_with_name` should be able to generate required data and write data inside `yt_array` array without ghost cell. Make sure your function writes the data in x-address alters first orientation (which is [z][y][x]), if `swap_axes` is set to `true`. Write the data in z-address alters first orientation (which is [x][y][z]), if `swap_axes` is set to `false`.

- `yt_array`
  - Usage: a struct used in derived function.
  - Data Member:
    - `long gid`: grid id.
    - `long data_length`: length of `data_ptr`.
    - `void *data_ptr`: data pointer where you should write in field data of this grid.




### Get Grid Information API

#### yt\_getGridInfo\_Dimensions
```cpp
int yt_getGridInfo_Dimensions( const long gid, int (*dimensions)[3] );
```
- Usage: Get dimension of the grid id `gid`, `dimensions[0]` corresponds to length of x, `dimensions[1]` corresponds to length of y, and `dimensions[2]` corresponds to length of z.
- Return: `YT_SUCCESS` or `YT_FAIL`

#### yt\_getGridInfo\_FieldData
```cpp
int yt_getGridInfo_FieldData( const long gid, const char *field_name, yt_data *field_data);
```
- Usage: Get the field data `field_name` in grid id `gid`. The result will be stored in `field_data`.
- Return: `YT_SUCCESS` or `YT_FAIL`
- `yt_data`
  - `data_ptr`: Data pointer.
  - `data_dimensions[3]`: Dimension of the `data_ptr` array, in the point of view of itself.
  - `data_dtype`: Data type of the array.

> :information_source: Do not mix grid dimensions get by `yt_getGridInfo_Dimensions` with data dimensions get by `yt_getGridInfo_FieldData`. Grid dimensions are grid length in [0][1][2] <-> [x][y][z]. Whereas data dimensions are just data length in data's point of view, which may consist of ghost cells.

> :warning: You should not be modifying `data_ptr`, as they are those data pointers you passed in and will be used in your later on iterations.

## Example
Field `level_derived_func` and `level_derived_func_with_name` have grid data equal to their grid level. Function `level_derived_func` and `level_derived_func_with_name` will generate the grid data and write to corresponding data pointer.
```c++
/* libyt API */  
yt_field *field_list;  
yt_get_fieldsPtr( &field_list );

/* We have three field in this example. */ 
// (2) derived field "level_derived_func"
field_list[1].field_name = "level_derived_func";
field_list[1].field_define_type = "derived_func";
field_list[1].swap_axes = true;
field_list[1].field_dtype = ( typeid(real) == typeid(float) ) ? YT_FLOAT : YT_DOUBLE;
field_list[1].derived_func = level_derived_func;
// (3) derived field "level_derived_func_with_name"
field_list[2].field_name = "level_derived_func_with_name";
field_list[2].field_define_type = "derived_func";
field_list[2].swap_axes = true;
field_list[2].field_dtype = ( typeid(real) == typeid(float) ) ? YT_FLOAT : YT_DOUBLE;
field_list[2].derived_func_with_name = level_derived_func_with_name;

void level_derived_func(int list_len, long *gid_list, yt_array *data_array){
    // loop over gid_list, and fill in grid data inside data_array.
    for(int lid=0; lid<list_len; lid++){
        // Get grid level by gid.
        int level;
        getLevelByGID(gid_list[lid], &level);

        // Get grid dimension by libyt API.
        int dim[3];
        yt_getGridInfo_Dimensions(gid_list[lid], &dim );

        // Fill in data
        int index;
        for(int k=0; k<dim[2]; k++){
            for(int j=0; j<dim[1]; j++){
                for(int i=0; i<dim[0]; i++){
                    index = k * dim[1] * dim[0] + j * dim[0] + i;
                    // Get the point and store data.
                    ((real*)data_array[lid].data_ptr)[index] = (real) level;
                }
            }
        }
    }
}

void level_derived_func_with_name(int list_len, long *gid_list, char *field, yt_array *data_array){
    /* Same as above.*/
}
```