---
layout: default
title: Using yt
parent: In Situ Python Analysis
nav_order: 2
---
# Using yt for In Situ Python Analysis
{: .no_toc }
<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>
---

{: .notes }
TODO: START HERE


The inline python script and the simulation executable should be placed in the same location. The script is only read once by `libyt` at the initialization stage and only one script can be loaded in the runtime, so user should put all their functions in one file. `libyt` will then call these python functions in the runtime.

> :information_source: If we want to reload our script multiple times and make changes to python functions, please refer to [interactive mode](../libytAPI/ActivateInteractiveMode.md#activate-interactive-mode).

## Use yt for Parallel Computation
You should always include the three lines, then move all the other commands into python functions and replace `yt.load()` to `yt_libyt.libytDataset()`. For example,
```python
# inline script
import yt_libyt
import yt
yt.enable_parallelism()

def yt_inline():
    ds = yt_libyt.libytDataset()     # <--> yt.load("Data")
    proj = yt.ProjectionPlot(ds, "density")
    if yt.is_root():
        proj.save()
```
> :information_source: We have borrowed parallel computation feature in `yt`, you can also refer to [Parallel Computation With yt](https://yt-project.org/doc/analyzing/parallel_computation.html#parallel-computation-with-yt).

## Supported yt Functionalities

|       `yt` Function      | Supported | Notes                                    |
|:------------------------:|:---------:|------------------------------------------|
| `find_max`               |     V     |                                          |
| `ProjectionPlot`         |     V     |                                          |
| `OffAxisProjectionPlot`  |     V     |                                          |
| `SlicePlot`              |     V     |                                          |
| `OffAxisSlicePlot`       |     V     |                                          |
| `covering_grid`          |     V     |                                          |
| 1D `create_profile`      |     V     |                                          |
| 2D `create_profile`      |     V     |                                          |
| `ProfilePlot`            |     V     |                                          |
| `PhasePlot`              |     V     |                                          |
| `LinePlot`               |     V     |                                          |
| Halo Analysis            |           | Not test yet.                            |
| Isocontours              |     V     |                                          |
| `volume_render`          |     V     | Only when MPI size is even will it work. |
| `ParticlePlot`           |     V     |                                          |
| `ParticleProjectionPlot` |     V     |                                          |

> :warning: When doing volume rendering, do *not* use `yt.is_root()` when saving outputs. Because this is not a serial process, it requires all ranks to work cooperatively.

## Distinguish libyt Fields and yt Fields
We use the term *`libyt` fields* for fields loaded or generated by `libyt`. The term *`yt` fields* is for fields defined in `XXXFieldInfo` in each frontends or yt defined intrinsic fields. `libyt` support both of them.

You should distinguish them when referring to fields in inline Python script.
- Add `frontend` name if you are referring to `libyt` fields. An example of calling `libyt` fields in `gamer` frontend:
  ```python
  def yt_inline():
      ds = yt_libyt.libytDataset()
      sz = yt.ProjectionPlot(ds, 'z', ("gamer", "velocity_x"), center='c')
      if yt.is_root():
          sz.save()
  ```
  
- An example of calling `yt` fields:
  ```python
  def yt_inline():
      ds = yt_libyt.libytDataset()
      sz = yt.ProjectionPlot(ds, 'z', "velocity_x", center='c')
      if yt.is_root():
          sz.save()
  ```

